// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"

	"golang.org/x/tools/go/packages"
)

const (
	modelpbPackage = "github.com/elastic/apm-server/model/modelpb"
)

var manualTypes = map[string]bool{
	"github.com/elastic/apm-server/model/modelpb.AnyValue":     true,
	"github.com/elastic/apm-server/model/modelpb.AnyValueList": true,
	"github.com/elastic/apm-server/model/modelpb.KeyValueList": true,
	"github.com/elastic/apm-server/model/modelpb.KeyValue":     true,
}

func main() {
	if err := Main(); err != nil {
		log.Fatal(err)
	}
}

func Main() error {
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, modelpbPackage)
	if err != nil {
		return fmt.Errorf("load: %w", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	var buf bytes.Buffer
	fmt.Fprintf(&buf, `
// Code generated by "modelgen". DO NOT EDIT.
package model

import (
	"time"

	%q
)
`[1:], modelpbPackage)

	pkg := pkgs[0]
	generator := generator{pb: pkg}

	for _, f := range pkg.Syntax {
		for _, decl := range f.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				obj := pkg.TypesInfo.Defs[typeSpec.Name]
				if obj == nil || !obj.Exported() {
					continue
				}
				typeName := obj.(*types.TypeName)
				named := typeName.Type().(*types.Named)
				if isManualType(named) {
					continue
				}
				switch {
				case hasMethod(named, "ProtoMessage"):
					generator.generateWrapperStruct(&buf, named, genDecl.Doc)
				}
			}
		}
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(buf.String())
		log.Fatal(err)
	}

	var out io.Writer = os.Stdout
	/*
		if outfile != "-" {
			f, err := os.Create(outfile)
			if err != nil {
				log.Fatal(err)
			}
			defer f.Close()
			out = f
		}
	*/
	if _, err := out.Write(formatted); err != nil {
		log.Fatal(err)
	}
	return nil
}

type generator struct {
	pb *packages.Package
}

func (g *generator) generateWrapperStruct(buf *bytes.Buffer, named *types.Named, doc *ast.CommentGroup) {
	structType := named.Underlying().(*types.Struct)

	// Define the wrapper struct type, with a "set" field which indicates
	// that the struct value is non-zero, and fields for holding values
	// for pointer fields in modelpb structs.
	wrapper := wrapperTypeName(named)
	if doc != nil {
		for _, line := range doc.List {
			fmt.Fprintln(buf, line.Text)
		}
	}

	var hasManual bool
	numFields := structType.NumFields()
	isManualField := make([]bool, numFields)
	for i := 0; i < numFields; i++ {
		field := structType.Field(i)
		if !field.Exported() {
			continue
		}
		if isManualType(field.Type()) {
			hasManual = true
			isManualField[i] = true
		}
	}

	fmt.Fprintf(buf, "type %s struct {\n", wrapper)
	if hasManual {
		fmt.Fprintf(buf, "  mixin%s\n", wrapper)
	}
	//fmt.Fprintf(buf, "  pb modelpb.%s\n", named.Obj().Name())

	hasWrapperField := make([]bool, numFields)
	for i := 0; i < numFields; i++ {
		field := structType.Field(i)
		if !field.Exported() || isManualField[i] {
			continue
		}
		switch fieldType := field.Type().(type) {
		case *types.Pointer, *types.Slice:
			hasWrapperField[i] = true
			name := wrapperTypeName(fieldType)
			fmt.Fprintf(buf, "  %s %s\n", field.Name(), name)
		}
	}
	fmt.Fprintf(buf, "}\n\n")

	/*
		// Define setters.
		for i := 0; i < numFields; i++ {
			field := structType.Field(i)
			if !field.Exported() || isManualField[i] {
				continue
			}
			wrappedArg := wrapperTypeName(field.Type())
			fmt.Fprintf(buf, "func (w *%s) Set%s(v %s) {\n", wrapper, field.Name(), wrappedArg)
			fmt.Fprintf(buf, "  w.set = true\n")
			if !hasWrapperField[i] {
				fmt.Fprintf(buf, "  w.pb.%s = (%s)(v)\n", field.Name(), types.TypeString(field.Type(), (*types.Package).Name))
			} else {
				wrapperFieldSelector := fmt.Sprintf("w.field%s", field.Name())
				pbFieldSelector := fmt.Sprintf("w.pb.%s", field.Name())
				fmt.Fprintf(buf, "  %s = %s\n", wrapperFieldSelector, "v")
				generateCopyToProto(buf, field.Type(), wrapperFieldSelector, pbFieldSelector)
			}
			fmt.Fprintf(buf, "}\n\n")
		}
	*/
}

func generateCopyToProto(buf *bytes.Buffer, typ types.Type, wrapperField, pbField string) {
	switch typ := typ.(type) {
	case *types.Pointer:
		elem := typ.Elem().(*types.Named)
		switch pkgpath := elem.Obj().Pkg().Path(); pkgpath {
		case modelpbPackage:
			fmt.Fprintf(buf, "%s = &%s.pb\n", pbField, wrapperField)
		case "time":
			fmt.Fprintf(buf, "%s = &%s\n", pbField, wrapperField)
		default:
			panic(fmt.Errorf("unhandled package path %q", pkgpath))
		}
	case *types.Slice:
		fmt.Fprintf(buf, "%s = %s[:0]\n", pbField, pbField)
		fmt.Fprintf(buf, "for _, slicev := range %s {\n", wrapperField)
		fmt.Fprintf(buf, "var elem %s\n", types.TypeString(typ.Elem(), (*types.Package).Name))
		generateCopyToProto(buf, typ.Elem(), "slicev", "elem")
		fmt.Fprintf(buf, "%s = append(%s, elem)\n", pbField, pbField)
		fmt.Fprintf(buf, "}\n")
	case *types.Basic:
		fmt.Fprintf(buf, "%s = %s\n", pbField, wrapperField)
	default:
		panic("unhandled type: " + typ.String())
	}
}

// isManualType reports whether or not the message type ha
// a manually defined wrapper.
func isManualType(typ types.Type) bool {
	switch typ := typ.(type) {
	case *types.Named:
		if typ.Obj().Pkg().Path() == modelpbPackage {
			return manualTypes[typ.String()]
		}
		return false
	case *types.Pointer:
		return isManualType(typ.Elem())
	case *types.Slice:
		return isManualType(typ.Elem())
	case *types.Basic:
		return false
	}
	panic("unhandled type: " + typ.String())
}

// wrapperTypeName returns the name of the wrapper for typ, if it is wrapped,
// or the original name otherwise.
func wrapperTypeName(typ types.Type) string {
	switch typ := typ.(type) {
	case *types.Named:
		switch pkgpath := typ.Obj().Pkg().Path(); pkgpath {
		case modelpbPackage:
			return typ.Obj().Name()
		case "time":
			return types.TypeString(typ, (*types.Package).Name)
		default:
			panic(fmt.Errorf("unhandled package path %q", pkgpath))
		}
	case *types.Pointer:
		return wrapperTypeName(typ.Elem())
	case *types.Slice:
		return "[]" + wrapperTypeName(typ.Elem())
	case *types.Basic:
		return typ.String()
	}
	panic("unhandled type: " + typ.String())
}

func hasMethod(named *types.Named, method string) bool {
	for i := named.NumMethods() - 1; i >= 0; i-- {
		if named.Method(i).Name() == method {
			return true
		}
	}
	return false
}
